# 최적의 코딩을 결정하는 기본 알고리즘

빅데이터 기반 지능형 서비스 개발 수업

강사 나동빈





## 1. 가장 기본이 되는 자료구조: 스택과 큐



### 1.1 스택 자료구조

- 선입후출의 자료 구조

- 프링글스 과자통과 비슷한 출입구가 통일한 형태
- Python에서는 리스트, append와 pop으로 구현 가능



### 1.2 큐 자료구조

- 선입선출의 구조
- 입구와 출구와 모두 뚫려있는 터널과 같은 형태
- 먼저 들어온 자료가 먼저 나가는 형태
- Python에서는 deque 라이브러리 사용함, append와 popleft로 구현가능



## 2. 우선순위에 따라 데이터를 꺼내는 자료 구조



### 2.1 우선순위 큐(Priority Queue)

- 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료 구조
- 리스트 이용하거나 - 복잡도1, 삭제시간 N
- 힙(heap)을 이용하여 구현 - 복잡도 logN, 삭제시간 logN



#### 힙(heap)

- 완전 이진 트리
  - Complete Binary Tree
  - 루트 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터 삽입
- 루트 노드를 제거하는 방식
  - 최소 힙(min heap): 루트 노드가 가장 작은 값을 가짐
  - 최대 힙(max heap): 루트 노드가 가장 큰 값을 가짐

##### 최소 힙 구성함수 Min-Heapify()

- 상향식: 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체
- 힙에 새로운 원소가 삽입될 때, logN의 시간 복잡도로 힙 성질 유지
- 힙에서 원소가 제거될 때 마지막 노드가 루트 노드의 위치에 오도록 함
- Python에서는 heapq 라이브러리 이용, heappush로 구현
- max 쓰고 싶으면 -를 붙이면 됨



## 3. 활용도가 높은 자료구조: 트리 자료구조



### 3.1 트리(Tree)

- 가계도와 같은 계층적인 구조 
- root node: 부모가 없는 최상위 노드
- 단말 노드 leaf node: 자식이 없는 노드
- 트리의 크기가 n일 때, 전체 간선의 개수는 n-1개



### 3.2 이진 탐색 트리(Binary Search Tree)

- 이진 탐색이 동작할 수 있도록 고안된 자료 구조
- 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
- 루트 노드부터 방문해서 탐색 진행, 오른/왼 보고 찾고자 하는 자료와 가까운 곳으로 이동



### 3.3 트리의 순회(Tree Traversal)

- 노드에 한 번씩 방문하는 방법
  - 전위 순회(pre-order): 루트 먼저 방문
  - 중위 순회(in-order): 왼쪽 먼저 방문
  - 후회 순회(post-order): 오른쪽 먼저 방문
- Python에서는 노드 Class로 구현



## 4. 특수한 목적의 자료구조: 바이너리 인덱스 트리



### 4.1 바이너리 인덱스 트리(Binary Indexed Tree)

- 데이터의 변경이 가능한 상황에서에 합을 구해야 할 때
- 2진법 인덱스 구조를 활용해 문제 해결
- 펜윅 트리(fenwick tree)라고도 함
- 정수에 따른 2진수 표기: K & -K 로 계산
- 누적 합 구할때: Prefix Sum, 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산



### 4.2 트리 구조 만들기

- 0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수

- 특정 값을 변경할 때: 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경





## 5. 정렬 알고리즘(선택과 삽입)

- 정렬(Sorting)은 데이터를 특정한 기준에 따라 순서대로 나열하는 것



### 5.1 선택 정렬

- 처리되지 않은 데이터 중 가장 작은 데이터를 선택해서 맨 앞에 있는 것과 바꿈
- Python에서는 min_index로 선형 탐색을 시작하여 특정 원소와 스와프 연산으로 표현
- 복잡도는 O(N**2)



### 5.2 삽입 정렬

- 처리되지 않은 데이터를 골라서 적절한 위치에 삽입
- 구현 난이도가 높고, 효율적으로 작용
- 두번째 데이터부터 첫번째 데이터의 오른/왼 비교하여 적절한 위치에 삽입
- Python에서는 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
- 시간 복잡도 0(N**2)



## 6. 퀵 정렬과 계수 정렬



### 6.1 퀵 정렬

- 기준 데이터보다 큰 데이터와 작은 데이터의 위치를 바꿈
- 대부분의 정렬 라이브러리에서 사용됨
- 첫번째 데이터를 Pivot으로 설정
- 피벗을 기준으로 왼쪽에서는 큰 데이터, 오른쪽에서는 작은 데이터를 골라서 위치 변경
- 데이터가 왼/오른이 분할(Divide) 됨
- 이상적인 경우, 분할이 절반씩 일어난다면 NlogN = 너비 X 높이



- Python에서는 피벗보다 큰/작은 데이터를 찾을 때까지 반복, 엇갈렸다면 작은 데이터를 교체
- 리스트 슬라이싱, 표현식으로 사용



### 6.2 계수 정렬

- 특정한 조건이 부합할 때만 사용, 매우 빠르게 동작
- 정수로 표현할 수 있을 때만 사용 가능
- 각각의 데이터를 count하는 방법 (상수 시간에 접근 가능,,,?)
- Python에서는 각 데이터에 해당하는 인덱스의 값을 1씩 증가, 리스트에 기록된 정렬 정보 확인
- 동일한 데이터가 여러 개 등장할 때 효과적으로 사용 







